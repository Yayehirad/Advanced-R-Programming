---
title: "Functions"
author: "Yayehirad A Melsew"
date: "29/05/2021"
output: html_document
---
When writing R functions, one has to consider
- Functions are used to encapsulate a sequence of expressions that are executed together to achieve a specific goal.
- There is going to be a user who will desire the ability to modify certain aspects of your code to match their specific needs or application. 
# Example Code
```{r}
library(readr)
library(dplyr)

## Download data from RStudio (if we haven't already)
if(!file.exists("data/2016-07-20.csv.gz")) {
        download.file("http://cran-logs.rstudio.com/2016/2016-07-20.csv.gz", 
                      "data/2016-07-20.csv.gz")
}
cran <- read_csv("data/2016-07-20.csv.gz", col_types = "ccicccccci")
cran %>% filter(package == "filehash") %>% nrow
[1] 179
```
- What aspects of this code that one might want to modify or expand on? date and package
Once we've identified which aspects of a block of code we might want to modify or vary, we can take those things and abstract them to be arguments of a function.

# Example Function interface
The following function has two arguments:

- pkgname, the name of the package as a character string
- date, a character string indicating the date for which you want download statistics, in year-month-day format
Given the date and package name, the function downloads the appropriate download logs from the RStudio server, reads the CSV file, and then returns the number of downloads for the package.

```{r}
library(dplyr)
library(readr)

## pkgname: package name (character)
## date: YYYY-MM-DD format (character)
num_download <- function(pkgname, date) {
        ## Construct web URL
        year <- substr(date, 1, 4)
        src <- sprintf("http://cran-logs.rstudio.com/%s/%s.csv.gz",
                       year, date)

        ## Construct path for storing local file
        dest <- file.path("data", basename(src))

        ## Don't download if the file is already there!
        if(!file.exists(dest))
                download.file(src, dest, quiet = TRUE)

        cran <- read_csv(dest, col_types = "ccicccccci", progress = FALSE)
        cran %>% filter(package == pkgname) %>% nrow
}

```
Now we can call our function using whatever date or package name we choose.
Note that for this date, the CRAN log file had to be downloaded separately because it had not yet been downloaded.
```{r}
num_download("filehash", "2016-07-20")
```
# Example Default values
Default values play a critical role in R functions because R functions are often called interactively. When using R in interactive mode, it can be a pain to have to specify the value of every argument in every instance of calling the function. Sometimes we want to call a function multiple times while varying a single argument (keeping the other arguments at a sensible default).

Also, function arguments have a tendency to proliferate. As functions mature and are continuously developed, one way to add more functionality is to increase the number of arguments. But if these new arguments do not have sensible default values, then users will generally have a harder time using the function.

As a function author, you have tremendous influence over the user's behavior by specifying defaults, so take care in choosing them. However, just note that a judicious use of default values can greatly improve the user experience with respect to your function.
he way that the num.download() function is currently specified, the user must enter the date and package name each time the function is called. However, it may be that there is a logical "default date" for which we always want to know the number of downloads, for any package. We can set a default value for the date argument, for example, to be July 20, 2016. In that case, if the date argument is not explicitly set by the user, the function can use the default value. The revised function might look as follows:
```{r}
num_download <- function(pkgname, date = "2016-07-20") {
        year <- substr(date, 1, 4)
        src <- sprintf("http://cran-logs.rstudio.com/%s/%s.csv.gz",
                       year, date)
        dest <- file.path("data", basename(src))
        if(!file.exists(dest))
                download.file(src, dest, quiet = TRUE)
        cran <- read_csv(dest, col_types = "ccicccccci", progress = FALSE)
        cran %>% filter(package == pkgname) %>% nrow
}
```
Now we can call the function in the following manner. Notice that we do not specify the date argument.
```{r}
num_download("Rcpp")
```

# Example Re-factoring code
Asking whether it is written in the most useful possible manner
In particular, it could be argued that this function does too many things:

Construct the path to the remote and local log file
Download the log file (if it doesn't already exist locally)
Read the log file into R
Find the package and return the number of downloads
It might make sense to abstract the first two things on this list into a separate functioncalled check_for_logfile() to see if we need to download the log file and 
then num_download() could call this function.

```{r}
check_for_logfile <- function(date) {
        year <- substr(date, 1, 4)
        src <- sprintf("http://cran-logs.rstudio.com/%s/%s.csv.gz",
                       year, date)
        dest <- file.path("data", basename(src))
        if(!file.exists(dest)) {
                val <- download.file(src, dest, quiet = TRUE)
                if(!val)#adds a bit of error checking to see if download.file()was successful (if not, an error is                           thrown with stop())
                        stop("unable to download file ", src)
        }
        dest #
}
```
then num_download() could call this function.
```{r}
num_download <- function(pkgname, date = "2016-07-20") {
        dest <- check_for_logfile(date)
        cran <- read_csv(dest, col_types = "ccicccccci", progress = FALSE)
        cran %>% filter(package == pkgname) %>% nrow
}    
```
Dependency Checking




